<html>

<head>
<title>Brian Blaylock, UofU</title>
<link rel="stylesheet" href="./css/brian_style.css" />
<script src="./js/site/siteopen.js"></script>
</head>


<body>
<a name="TOP"></a>
<script src="./js/site/sitemenu.js"></script>	

<br>
<h1 align="center">WRF Post Processing Examples</h1>
<div id="content">

<ul style="padding: 10px; margin-left:30px;">
<li><a href="wrf_post.html#BROWSER">WRF Browser</a>
<li><a href="wrf_post.html#PLUME">Tracer Plume</a>
<li><a href="wrf_post.html#STAG2MASS">Convert Staggered Grid to Mass Points</a>
<li><a href="wrf_post.html#MULTI">Plots on Multiprocessors</a>
<li><a href="wrf_post.html#NCL">NCL</a>
<li><a href="wrf_post.html#ETA_2_PRESS">Convert ETA levels to Pressure Coordinate</a>
</ul>
External Links
<ul style="padding: 10px; margin-left:30px;">
<li><a href="https://github.com/lmadaus/old_wrf_plotting_scripts"> Lukes' Code (Good starting place)</a>
<li><a href="http://www.enviroware.com/WRF_Browser/" target="_blank">WRF Browser (Windows)</a> <-- Yeah, check this out!

</ul>

<hr>
<br>

<!--*****************************************-->
<!--*****************************************-->

<div class="section">
<a name="TUTORIAL"></a>
<h3>Under Construction</h3>
<p>check back later for updates and new examples.
<p> Someday when I get around to it I'll post my codes on <a href="https://github.com/blaylockbk">GitHub</a>
<a href="wrf_post.html#TOP">Back to Top</a>
</div>
<br>

<!--*****************************************-->
<!--*****************************************-->



<div class="section">
<a name="BROWSER"></a>
<h3>WRF Browser</h3>
<p>WRF Browser is a Windows application that lets you browser WRF variables, plot variable field on a map, 
export variable to KML, and create time series plots for a point.
<p>Download the latest version <a href="http://www.enviroware.com/WRF_Browser/">here</a> and join the email list for new updates. This is still being produced
and my experience is that if you report a bug they get it fixed rather quickly. 
<a href="wrf_post.html#TOP">Back to Top</a>
</div>
<br>

<!--*****************************************-->
<!--*****************************************-->

<br>
<div class="section">
<a name="PLUME"></a>
<h3>Plotting High Frequency Tracer Plumes</h3>
<p> Python code to read data from an <i>auxhist23_d01_2015-06-18_00:00:00</i> file

<textarea class="Python" disabled>
# Created by Brian Blaylock
# September 2, 2015
#
# Plotting WRF netCDF output
# Parts and Pieces of this code is from Luke Madaus (University of Washington)


import sys,getopt
#from netCDF4 import Dataset  # use scipy instead
from scipy.io import netcdf
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import os
from datetime import datetime, timedelta
import coltbls as coltbls
from mpl_toolkits.basemap import Basemap
from matplotlib.colors import LinearSegmentedColormap
from mpl_toolkits.axes_grid import make_axes_locatable
import matplotlib.axes as maxes
#import mayavi.mlab as mlab #Used for 3d Plotting


# Running Script example:
# $ python my_WRF_map.py wrfout_d0x_YYYY-MM-DD_HH:MM:SS

# list of files
#d02 = ['WTDE8Z~0','W2TFAX~5','W1PEFC~6','WKBXUM~Z','WAMGEL~S','WWZHSX~P']
#d02 = ['WKBXUM~Z']
d02 = ['June18plume']
for output_file in d02:
    # Open file in a netCDF reader   
    directory = './June182015_chopper/'
    out_dir = './Plume_Maps/'
    wrf_file_name = output_file #NC files are named differently in a windows system
    print 'opening', directory+wrf_file_name
    nc         = netcdf.netcdf_file(directory+wrf_file_name,'r')
    nc_spatial = netcdf.netcdf_file(directory+'June18SpatialData','r')
    
    
    
    #-------------------------------------------
    # Creat the basemap only once per domain. (This significantly speeds up the plotting speed)
    #-------------------------------------------
    
    # x_dim and y_dim are the x and y dimensions of the model
    # domain in gridpoints
    x_dim = nc.dimensions['west_east']
    y_dim = nc.dimensions['south_north']
    
    # Get the grid spacing
    dx = float(nc.DX)
    dy = float(nc.DY)
    
    width_meters = dx * (x_dim - 1)		#Domain Width
    height_meters = dy * (y_dim - 1)	#Domain Height
    
    cen_lat = float(nc.CEN_LAT)
    cen_lon = float(nc.CEN_LON)
    truelat1 = float(nc.TRUELAT1)
    truelat2 = float(nc.TRUELAT2)
    standlon = float(nc.STAND_LON)
    
    # Draw the base map behind it with the lats and
    # lons calculated earlier
    m = Basemap(resolution='i',projection='lcc',\
        width=width_meters,height=height_meters,\
        lat_0=cen_lat,lon_0=cen_lon,lat_1=truelat1,\
        lat_2=truelat2)
    	
    # This sets the standard grid point structure at full resolution
    #	Converts WRF lat and long to the maps x an y coordinate
    XLONG = nc_spatial.variables['XLONG'][0]
    XLAT  = nc_spatial.variables['XLAT'][0]
    x,y = m(XLONG,XLAT)    
    
    
    for t in np.arange(0,int(np.shape(nc.variables['Times'])[0])):
        # Grab these variables for now
        #landmask =  nc.variables['LANDMASK']				# HRRR metgrid landmask
        
        time = ''.join(nc.variables['Times'][t])
        time_dt = datetime.strptime(time,'%Y-%m-%d_%H:%M:%S')
        time_str= datetime.strftime(time_dt,'%Y-%m-%d %H:%M:%S UTC')
        time_str_local=datetime.strftime(time_dt-timedelta(hours=6),'%Y-%m-%d %H:%M:%S MDT')
        time_file=datetime.strftime(time_dt,'%Y%m%d%H%M%S')
        HGT = nc_spatial.variables['HGT'][0,:,:] #topography
        landmask = nc_spatial.variables['LANDMASK'][0,:,:]
        plume = nc.variables['tr17_1'][t][0]
        #d = nc.variables['tr17_2'][0]
        #mlab.contour3d(d)
        
        
        # This sets a thinn-ed out grid point structure for plotting
        # wind barbs at the interval specified in "thin"
        #thin = 5 
        #x_th,y_th = m(XLONG[0,::thin,::thin],XLAT[0,::thin,::thin])
        	
        # Set universal figure margins
        width = 10
        height = 8
        plt.figure(t+1)
        print 'Plotting',time_str
        plt.figure(figsize=(width,height))
        plt.rc("figure.subplot", left = .001)	#gets rid of white space in plot
        plt.rc("figure.subplot", right = .999)
        plt.rc("figure.subplot", bottom = .001)
        plt.rc("figure.subplot", top = .999)
        
        F = plt.gcf()  # Gets the current figure
        
        m.drawstates(color='k', linewidth=1.25)
        m.drawcoastlines(color='k')
        m.drawcountries(color='k', linewidth=1.25)
        
    ######################################################
        
        plt.pcolormesh(x,y,landmask)
        #plt.pcolormesh(x,y,plume,cmap='PuOr', vmin=0,vmax=.01)
        plt.pcolormesh(x,y,plume,cmap='PuOr')
        cbar_loc = plt.colorbar(shrink=.8)
        cbar_loc.ax.set_ylabel('plume [units?]')
        plt.contour(x,y,landmask, [0,1], linewidths=1, colors="k")
        #plt.contour(x,y,HGT)
        
        xs,ys = m(-111.97,40.78) #buffr sounding coordinates
        plt.scatter(xs,ys, s=70, c='w')
        plt.title(time_str+'\n'+time_str_local, bbox=dict(facecolor='white', alpha=0.65),\
    			x=0.5,y=.90,weight = 'demibold',style='oblique', \
    			stretch='normal', family='sans-serif')    
        plt.savefig(out_dir+'plume_'+time_file+'.jpg',dpi=300)
        print 'Saved',time_str

        #plt.show()

</textarea>

<p> Then, in a Linux terminal, use the convert command to convert all the images into an animated GIF.
<textarea class="Linux" disabled >
convert *.jpg plume_anima.gif
</textarea>

<p> Below is an example of a plume with WRF output every 10 minutes.
<img class="style1" src = 'images/plume_ex3.gif' width=90%>
	
<br><br>
<a href="wrf_post.html#TOP">Back to Top</a>
</div>

<br>
<!--*****************************************-->
<!--*****************************************-->

<div class="section">
<a name="STAG2MASS"></a>
<h3>Converting Staggered Grid Variables to Mass Points (by averaging)</h3>

<p><a href="https://github.com/blaylockbk/Ute_WRF/blob/master/functions/stagger_to_mass.py"><img align=right src="./images/githubcode.png"></a>
WRF uses the <a href="http://www.openwfm.org/wiki/How_to_interpret_WRF_variables#Grid" target="_blank">Arakawa C Grid</a>.
Mass point variables like temperature, humidity, etc. are calculated for the inside of the gird box.
Advection variables like U and V winds are calculated on a staggered grid
for the box edges to represent flow into and out of the box.
<p> If you're dealing with WRF output data on certain model levels rather than surface variables
you it's likely you'll need to convert the staggered grid variables to the mass points. One reason 
you'd want to do this is if you want to make wind barbs.
<p> <img align=right width='35%' src="./images/arakawa-C-grid.png">
<p> To the left is a 3x3 Arakawa C-Grid.
<ul>
<li> Red Dots: mass point (3x3)
<li> Blue Line: U staggered (3x4)
<li> Green Line: V staggered (4x3)
</ul>
<p>The U and V array size will be one column or row bigger than your mass point array.
You could get away with trimming the U and V array to the same size as the mass point array
and then plot the U and V winds on the mass point lat/lon coordinates. This introduces a small error half the size
of your grid spacing (4 km grid box would cause a 2 km error in wind barb placement). That is sloppy, and
we can do better. So we reduce the staggered grid to a mass point grid by averaging the values on the left-right
side of the box to get an average U vector at the mass point and then average the top-bottom value to get the V
average value. Get it? Here's some more details...
<h4>stagger_to_mass.py</h4>
<p>
Two simple python functions to convert the staggered grid values (U, V, winds, and lat/lons) to the mass point. 
I average the outside coordinates to approximate the masspoint value in the middle.

<textarea class="python">
# Brian Blaylock
# April 7, 2016

# Two functions to conver V and U staggered grids to mass points.
# For example:
# Usefull to convert U winds, XLAT_U, and XLONG_U, to a mass point
# using basic averaging between the left and right side of the grid point.
        
import numpy as np  
          
def Vstagger_to_mass(V):
    """
    V are the data on the top and bottom of a grid box    
    A simple conversion of the V stagger grid to the mass points.
    Calculates the average of the top and bottom value of a grid box. Looping
    over all rows reduces the staggered grid to the same dimensions as the 
    mass point.
    Useful for converting V, XLAT_V, and XLONG_V to masspoints
    Differnce between XLAT_V and XLAT is usually small, on order of 10e-5
    
    (row_j1+row_j2)/2 = masspoint_inrow
    
    Input:
        Vgrid with size (##+1, ##)
    Output:
        V on mass points with size (##,##)
        
    """
    
    # create the first column manually to initialize the array with correct dimensions
    V_masspoint = (V[0,:]+V[1,:])/2. # average of first and second column
    V_num_rows = int(V.shape[0])-1 # we want one less row than we have
    
    # Loop through the rest of the rows
    # We want the same number of rows as we have columns.
    # Take the first and second row, average them, and store in first row in V_masspoint
    for row in range(1,V_num_rows):
        row_avg = (V[row,:]+V[row+1,:])/2.
        # Stack those onto the previous for the final array        
        V_masspoint = np.row_stack((V_masspoint,row_avg))
    
    return V_masspoint
    
def Ustagger_to_mass(U):
    """
    U are the data on the left and right of a grid box    
    A simple conversion of the U stagger grid to the mass points.
    Calculates the average of the left and right value of a grid box. Looping
    over all columns it reduces the staggered grid to the same dimensions as the 
    mass point.
    Useful for converting U, XLAT_U, and XLONG_U to masspoints
    Differnce between XLAT_U and XLAT is usually small, on order of 10e-5
    
    (column_j1+column_j2)/2 = masspoint_incolumn
    
    Input:
        Ugrid with size (##, ##+1)
    Output:
        U on mass points with size (##,##)
        
    """
    
    # create the first column manually to initialize the array with correct dimensions
    U_masspoint = (U[:,0]+U[:,1])/2. # average of first and second row
    U_num_cols = int(U.shape[1])-1 # we want one less column than we have
    # Loop through the rest of the columns
    # We want the same number of columns as we have rows.
    # Take the first and second column, average them, and store in first column in U_masspoint
    for col in range(1,U_num_cols):
        col_avg = (U[:,col]+U[:,col+1])/2.
        # Stack those onto the previous for the final array        
        U_masspoint = np.column_stack((U_masspoint,col_avg))
    
    return U_masspoint
        
if __name__=="__main__":
    V = np.array([[1,2,3],[4,5,6],[7,8,9],[1,2,3]])
    print V
    a = Vstagger_to_mass(V)
    print a

    print ""
    print ""

    U = np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])
    print U
    b = Ustagger_to_mass(U)
    print b
</textarea>
<br><br>
<h4>Vstagger_to_mass(V)</h4>
<p> Average the top and bottom column values for each box. Perform the following calculation on the array and loop through all rows.
<img width="90%" src="./images/avg_columns.png">
<br><br>
<h4>Ustagger_to_mass(U)</h4>
<p> Average the left and right row values for each box. Perform the following calculation on the array and loop through all columns.
<img width="90%" src="./images/avg_rows.png">
<p>Each U and V variable has a coorespoinding XLAT_U, XLONG_U, XLAT_V, and XLONG_V variable as well. 
<p>Note: difference between XLAT_U and XLAT is small, on the order of 10e-5. (same with XLAT_V, XLONG_U, and XLONG_V). This means
you only have to calcuate the lat/lon from either the U or V variable to get the approximate masspoint lat/lon.
Difference in Umass and Ustagger can bigger, I've seen values between 0-5. We expect some difference here.

<br><br>
<a href="wrf_post.html#TOP">Back to Top</a>
</div>
<br>

<!--*****************************************-->
<!--*****************************************-->


<div class="section">
<a name="MULTI"></a>
<h3>Python Multiprocessing: Lots of plots fast</h3>
<p>I find myself making lots of the same kinds of plots but for different wrfout times. How do you make 400 images 
real quick? Use Python's Multiprocessing module.
<p>How does multiprocessing work? Your computer has multiple cores, or brains, that it can do work on. When you 
run a typical Python script it will send that job to one processor. With multiprocessing it will break up parts of
the code and solve each piece on different processors. There is a module called multi threading, but multi threading 
probably wont speed up making plots too much since for reasons explained in the video below. I like to use multiprocessing
and the pool function to split the code up among the working processors.
Check out the YouTube video for a bit more description...
<iframe width="560" height="315" src="https://www.youtube.com/embed/X2mO1O5Nuwg?rel=0" frameborder="0" allowfullscreen></iframe>
<p><a href="https://github.com/blaylockbk/Ute_other/blob/master/plot_TDWR_multiprocessor.py"><img align=right src="./images/githubcode.png"></a>
As an example, check out the below (incomplete) script for an example of the parts and pieces.
On 32 processors available on CHPC machines, I was able to make 475 plots in less than a minute
rather than the hour it took to run in serial (one processor).

<textarea class="python">
##---- Multiprocessing -------------------------------------------------------------------##
## There are a lot of data files for the two days of TDWR data that need to be plotted.
## We want to make these plots really fast, so use the multiprocessing module
## to create a separate plot on each available processor.
##      1) Place the plotting script in a function. 
##         The input (can only take one) is the file name of the data to be plotted
##      2) In the main program (bottom section of this script) 
##         a) creat a list of the file names (this simple loop is very fast)
##         b) count the number
##         c) creat the pool object p = multiprocessing.Pool(num_proc)
##         d) send each list item to the plot function with the pool function
## This method makes 475 plots in a few minutes rather than over an hour!!!
##---- Multiprocessing -------------------------------------------------------------------##


import multiprocessing #:)
import matplotlib.pyplot as plt
import numpy as np
#etc.

def make_plot(i):    
    # i is the name of the file we will open
    print i

    # etc. plotting functions
    # open the data file
    # process the data file
    # create the plot


## This is the good stuff...utilizing multiprocessors
if __name__ == '__main__':

    # List of file names we want to make plots for
    somelist = []
    for i in os.listdir('./'):
        if i[0:3]=='SLC' and i[-3:]=='asc': # get the file name of all TDWR files
            somelist.append(i)      

    # Count number of processors
    num_proc = multiprocessing.cpu_count()
    
    # Create a pool with the number of processors that are available on the computer
    p = multiprocessing.Pool(num_proc)
    
    # With that pool, use the map function to send jobs to the workers. 
    # p.map(the_function_we_want_to_complete, the_function_input_arguments)
    p.map(make_plot,somelist)
</textarea>

<a href="wrf_post.html#TOP">Back to Top</a>
</div>
<br>



<!--*****************************************-->
<!--*****************************************-->
<div class="section">
<a name="TUTORIAL"></a>
<h3>Under Construction</h3>
<p>check back later for updates and new examples.

<a href="wrf_post.html#TOP">Back to Top</a>
</div>
<br>

<!--*****************************************-->
<!--*****************************************-->
<br>
<div class="section">
<a name="ETA_2_PRESS"></a>
<h3>Converting ETA levels in WRF to Pressure Levels</h3>
<p> <a href="http://www.shodor.org/os411/courses/_master/tools/calculators/etacoordinates/"> Equation here.</a> 

<br><br>
<a href="wrf_post.html#TOP">Back to Top</a>
</div>

<!--*****************************************-->
<!--*****************************************-->
<br>
<div class="section">
<a name="netCDF"></a>
<h3>Basics of using netCDF data in Python</h3>
<p> These are some basic snippets of code for dealing with netCDF in Python.
<textarea class="Python">
import sys,getopt
#from netCDF4 import Dataset  # use scipy instead
from scipy.io import netcdf #### <--- This is the library to import.
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import os
from datetime import datetime, timedelta
import coltbls as coltbls
from mpl_toolkits.basemap import Basemap
from matplotlib.colors import LinearSegmentedColormap
from mpl_toolkits.axes_grid import make_axes_locatable
import matplotlib.axes as maxes


# Running Script example:
# $ python my_WRF_map.py wrfout_d0x_YYYY-MM-DD_HH:MM:SS

# Open file in a netCDF reader
directory = './'
wrf_file_name = directory+'W0NQXP~N' #NC files are named funny in a windows system
nc = netcdf.netcdf_file(wrf_file_name,'r')

#Look at the variables available
nc.variables

#Look at the dimensions
nc.dimensions

#Look at a specific variable's dimensions
nc.variables['T2'].dimensions   ## output is ('Time', 'south_north', 'west_east')

#Look at a specific variable's units
nc.variables['T2'].units        ## output is ('K')

</textarea>

<br><br>
<a href="wrf_post.html#TOP">Back to Top</a>
</div>
<br>
<br>
<!--*****************************************-->
<!--*****************************************-->
<div class="section">
<a name="NCL"></a>
<h3>Plotting WRF data with NCAR Command Language (NCL)</h3>
<p> Converting WRF vertical coordinates to pressure surfaces is not a trivial task. I needed to 
plot winds and other output on pressure surfaces rather than ETA coordinates, so I use NCL to make 
these plots. There is a built in function that interpolates the WRF output onto pressure coordinates.
I'll share a python function when I get around to building my own. For now, I suggest using NCL.

<p> You can download the current release of NCL <a href="http://www.ncl.ucar.edu/current_release.shtml">here</a>.
I found the tutorial steps were simple to follow and complete. I managed to get NCL running without any issues
in about fifteen minutes.
<p> These example scripts are a great place to start (<a href="http://www2.mmm.ucar.edu/wrf/OnLineTutorial/Graphics/NCL/NCL_examples.htm">click here</a>)
I would suggest going through each of the basic plots and surface plots just to get a feel of 
how the language works.

<p> After making some edits to the pressure surface plots I was able to create this animation of winds on
a 500 mb pressure level. Shown are the wind barbs and the color fill is wind speed. The black contour lines shows
the terrain elevation.
<br><br>
<img class="style1" src="images/songnex_500mb_04272015.gif">
<br>
<textarea>
;   Example script to produce plots for a WRF real-data run,
;   with the ARW coordinate dynamics option.
;   Interpolating to specified pressure levels

load "$NCARG_ROOT/lib/ncarg/nclscripts/csm/gsn_code.ncl"
load "$NCARG_ROOT/lib/ncarg/nclscripts/wrf/WRFUserARW.ncl"


begin

; Deal with looping through dates


day = "27"

hour = (/"00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15","16","17","18","19","20","21","22","23"/)
do HOUR = 0,dimsizes(hour)-1,1
   print(hour(HOUR))


;
; The WRF ARW input file.  
; This needs to have a ".nc" appended, so just do it.
  a = addfile("/uufs/chpc.utah.edu/common/home/horel-group4/songnex/HRRR_wrf/wrfout_d01_2015-04-"+day+"_"+hour(HOUR)+":00:00.nc","r")


; We generate plots, but what kind do we prefer?
  type = "x11"
  type = "pdf"
; type = "ps"
; type = "ncgm"



; Set some Basic Plot options
  res = True
  res@MainTitle                   = "HRRR Wind Analysis"
  res@Footer = False

  pltres = True
  mpres = True
  mpres@mpGeophysicalLineColor      = "Black"
  mpres@mpNationalLineColor         = "Black"
  mpres@mpUSStateLineColor          = "Black"
  mpres@mpLimbLineColor             = "Black"
  mpres@mpPerimLineColor            = "Black"
  mpres@mpGeophysicalLineThicknessF = 2.0
  mpres@mpGridLineThicknessF        = 0.0
  mpres@mpLimbLineThicknessF        = 2.0
  mpres@mpNationalLineThicknessF    = 2.0
  mpres@mpUSStateLineThicknessF     = 2.0


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; What times and how many time steps are in the data set?
  times = wrf_user_getvar(a,"times",-1)  ; get all times in the file
  ntimes = dimsizes(times)         ; number of times in the file
  
; The specific pressure levels that we want the data interpolated to.
  pressure_levels = (/ 850., 775., 700., 500./)  ; pressure levels to plot
  nlevels         = dimsizes(pressure_levels)     ; number of pressure levels

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  do it = 0,ntimes-1,2             ; TIME LOOP

    print("Working on time: " + times(it) )
    res@TimeLabel = times(it)   ; Set Valid time to use on plots

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; First get the variables we will need        

    tc = wrf_user_getvar(a,"tc",it)        ; T in C
    u  = wrf_user_getvar(a,"ua",it)        ; u averaged to mass points
    v  = wrf_user_getvar(a,"va",it)        ; v averaged to mass points
    p  = wrf_user_getvar(a, "pressure",it) ; pressure is our vertical coordinate
    z  = wrf_user_getvar(a, "z",it)        ; grid point height
    rh = wrf_user_getvar(a,"rh",it)        ; relative humidity
	ter= wrf_user_getvar(a,"ter",it)       ; model terrain height
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    do level = 0,nlevels-1                 ; LOOP OVER LEVELS
	  
      pressure = pressure_levels(level)
	  print("working on pressure level: "+pressure)
	  
	  s_time = str_sub_str(times(it),":","")
	  wks = gsn_open_wks(type,"./figs/P"+pressure+"mb_T"+s_time)

      tc_plane = wrf_user_intrp3d(tc,p,"h",pressure,0.,False)
      z_plane  = wrf_user_intrp3d( z,p,"h",pressure,0.,False)
      rh_plane = wrf_user_intrp3d(rh,p,"h",pressure,0.,False)
      u_plane  = wrf_user_intrp3d( u,p,"h",pressure,0.,False)
      v_plane  = wrf_user_intrp3d( v,p,"h",pressure,0.,False)
	  

      spd     = (u_plane*u_plane + v_plane*v_plane)^(0.5) ; m/sec
      spd@description = "Wind Speed"
      spd@units = "m/s"
      ;u_plane = u_plane*1.94386     ; kts
      ;v_plane = v_plane*1.94386     ; kts
      ;u_plane@units = "kts"
      ;v_plane@units = "kts"


      ; Plotting options for T                
        opts = res                          
        opts@cnLineColor = "Red"
        opts@ContourParameters = (/ 5.0 /)
        opts@cnInfoLabelOrthogonalPosF = 0.07  ; offset second label information
        opts@gsnContourLineThicknessesScale = 2.0
        contour_tc = wrf_contour(a,wks,tc_plane,opts)
        delete(opts)


      ; Plotting options for RH                
        opts = res                          
        opts@cnFillOn = True  
        opts@pmLabelBarOrthogonalPosF = -0.1
        opts@ContourParameters = (/ 10., 90., 10./)
        opts@cnFillColors = (/"White","White","White", \
                              "White","Chartreuse","Green",\
                              "Green3","Green4", \
                              "ForestGreen","PaleGreen4"/)
        contour_rh = wrf_contour(a,wks,rh_plane,opts)
        delete(opts)
		

      ; Plotting options for Wind Speed                
        opts = res                          
        opts@cnLineColor = "MediumSeaGreen"
        opts@ContourParameters = (/ 10. /)
        opts@cnInfoLabelOrthogonalPosF = 0.07  ; offset second label information
        opts@gsnContourLineThicknessesScale = 3.0
		opts@cnLineColor = "Black"
        contour_spd = wrf_contour(a,wks,spd,opts)
        delete(opts)
      
	  ; Plotting options for Wind Speed color fill                
        opts = res                          
        opts@cnFillOn = True  
        opts@pmLabelBarOrthogonalPosF = -0.1
        opts@ContourParameters = (/ 0., 25., 5./)
        contour_wind_fill = wrf_contour(a,wks,spd,opts)
        delete(opts)

      ; Plotting options for Wind Vectors                 
        opts = res          
        opts@FieldTitle = "Wind"   ; overwrite Field Title
        opts@NumVectors = 47       ; wind barb density
        vector = wrf_vector(a,wks,u_plane,v_plane,opts)
        delete(opts)
		
	  ; Plotting options for Model Terrain Height
        opts = res                          
        opts@cnLineColor = "black"
        opts@ContourParameters = (/ 0., 7000., 250. /)
		opts@cnInfoLabelOn     = True
		opts@cnLineLabelsOn        = False    ; Turn off line labels.
        opts@gsnContourLineThicknessesScale = 0.5
        contour_ter = wrf_contour(a,wks,ter,opts)
        delete(opts)

      ; Plotting options for Geopotential Height
        opts_z = res                          
        opts_z@cnLineColor = "Blue"
        opts_z@gsnContourLineThicknessesScale = 3.0


      ; MAKE PLOTS                                       

        if ( pressure .eq. 850 ) then   ; plot temp, rh, height, wind barbs
          ;opts_z@ContourParameters = (/ 20.0 /)
          contour_height = wrf_contour(a,wks,z_plane,opts_z)
          plot = wrf_map_overlays(a,wks,(/contour_wind_fill, \
                                    contour_ter, vector/),pltres,mpres)
        end if

        if ( pressure .eq. 700 ) then   ; plot temp, height, wind barbs
          ;opts_z@ContourParameters = (/ 30.0 /)
          contour_height = wrf_contour(a,wks, z_plane,opts_z)
          plot = wrf_map_overlays(a,wks,(/contour_wind_fill, \
                                    contour_ter, vector/),pltres,mpres)
        end if

        if ( pressure .eq. 500 ) then   ; plot temp, height, wind barbs
          ;opts_z@ContourParameters = (/ 60.0 /)
          contour_height = wrf_contour(a,wks, z_plane,opts_z)
          plot = wrf_map_overlays(a,wks,(/contour_wind_fill, \
                                    contour_ter, vector/),pltres,mpres)
        end if

        if ( pressure .eq. 775 ) then   ; plot windspeed, height, wind barbs
          contour_height = wrf_contour(a,wks, z_plane,opts_z)
          plot = wrf_map_overlays(a,wks,(/contour_wind_fill, \
                                    contour_ter, vector/),pltres,mpres)
        end if
        delete(opts_z)

    end do      ; END OF LEVEL LOOP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  end do        ; END OF TIME LOOP
end do  ; END OF HOUR LOOPS
end
</textarea>

<br><br>
<a href="wrf_post.html#TOP">Back to Top</a>
</div>

<br>
<br>

<script src="./js/site/siteclose.js"></script>
</div>
</body>
</html>